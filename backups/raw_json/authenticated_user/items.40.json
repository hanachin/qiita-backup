[{"rendered_body":"\u003cp\u003e\u003cimg alt=\":hibiscus:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f33a.png\" title=\":hibiscus:\" width=\"20\"\u003e \u003ca href=\"http://qiita.com/advent-calendar/2016/okinawarb\"\u003eOkinawa.rbのAdvent Calendar 2016\u003c/a\u003e \u003cimg alt=\":pig2:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f416.png\" title=\":pig2:\" width=\"20\"\u003e 10日目です。\u003c/p\u003e\n\n\u003cp\u003eRubyでMethodオブジェクトを取り出すsyntaxが欲しいときってありますよね。ruby-coreで\u003ccode\u003eo.:method\u003c/code\u003eや\u003ccode\u003eo[.method]\u003c/code\u003eや\u003ccode\u003eo-\u0026gt;method\u003c/code\u003eなどが提案されていますがしっくりこないみたいです。\u003cbr\u003e\n\u003ca href=\"https://bugs.ruby-lang.org/issues/12125#change-57209\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\"\u003ehttps://bugs.ruby-lang.org/issues/12125#change-57209\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eRubyのsyntaxをいじる練習に提案されているsyntaxとは別のsyntaxを雑に実装してみようと思います。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"bulb-どういうsyntaxを実装するか\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#bulb-%E3%81%A9%E3%81%86%E3%81%84%E3%81%86syntax%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B%E3%81%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cimg alt=\":bulb:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f4a1.png\" title=\":bulb:\" width=\"20\"\u003e どういうsyntaxを実装するか\u003c/h2\u003e\n\n\u003cp\u003eここにオブジェクトがあります。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"rb\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"n\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"no\"\u003eObject\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003enew\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eオブジェクトのmethodメソッドの取り出し方を考えます。\u003c/p\u003e\n\n\u003cp\u003eとりだすメソッドの名前を指定しないと取り出せないので、とりあえずmethodと書く必要はあるでしょう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"rb\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"n\"\u003eo\u003c/span\u003e \u003cspan class=\"sr\"\u003e/*何かしらのsyntax*/\u003c/span\u003e \u003cspan class=\"nb\"\u003emethod\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eるりまの\u003ca href=\"https://docs.ruby-lang.org/ja/latest/doc/symref.html\" rel=\"nofollow noopener\" target=\"_blank\"\u003eRubyで使われる記号の意味\u003c/a\u003eや\u003ca href=\"https://docs.ruby-lang.org/ja/latest/doc/spec=2fliteral.html\" rel=\"nofollow noopener\" target=\"_blank\"\u003eリテラル\u003c/a\u003eのページを見ると記号はだいたい使われていそうです。\u003c/p\u003e\n\n\u003cp\u003eRubyではProcをつくるときに\u003ccode\u003e-\u0026gt; { }\u003c/code\u003e、ブロックを作るときに\u003ccode\u003efoo { }\u003c/code\u003eのように\u003ccode\u003e{}\u003c/code\u003eを使うことが多いですね。methodメソッドもProcやブロックと同じようにcallできるので同じように\u003ccode\u003e{}\u003c/code\u003eを使って書きたいです。\u003cbr\u003e\nなので、今回は\u003ccode\u003ereceiver.{method}\u003c/code\u003eでMethodオブジェクトを取り出せるようにしてみましょう。\u003c/p\u003e\n\n\u003cp\u003e以降\u003ccode\u003e.{}\u003c/code\u003e演算子と呼びます。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"wrench-準備\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#wrench-%E6%BA%96%E5%82%99\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cimg alt=\":wrench:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f527.png\" title=\":wrench:\" width=\"20\"\u003e 準備\u003c/h2\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"console\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"go\"\u003e% git clone git://github.com/ruby/ruby.git\n% cd ruby\n% git fetch --tags\n% git checkout -b method_method_syntax v2_4_0_preview3\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e今回はsyntax雑に足してみるのが目的なのでビルドは各自READMEを読んでやっていき \u003cimg alt=\":muscle:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f4aa.png\" title=\":muscle:\" width=\"20\"\u003e\u003cbr\u003e\n\u003ca href=\"https://github.com/ruby/ruby#how-to-compile-and-install\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\"\u003ehttps://github.com/ruby/ruby#how-to-compile-and-install\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"applepen_fountain-テスト\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#applepen_fountain-%E3%83%86%E3%82%B9%E3%83%88\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cimg alt=\":apple:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f34e.png\" title=\":apple:\" width=\"20\"\u003e\u003cimg alt=\":pen_fountain:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f58b.png\" title=\":pen_fountain:\" width=\"20\"\u003e テスト\u003c/h2\u003e\n\n\u003cp\u003e雑に足すだけなので以下でapplepenと表示されればいいことにします。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"rb\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"err\"\u003e㌰太郎\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"\"\u003c/span\u003e\n\u003cspan class=\"n\"\u003euh\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"err\"\u003e㌰太郎\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003econcat\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"err\"\u003e🍎\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"apple\"\u003c/span\u003e\n\u003cspan class=\"err\"\u003e✒️\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"pen\"\u003c/span\u003e\n\n\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"err\"\u003e🍎\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"err\"\u003e✒️\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"nf\"\u003eeach\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003euh\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"nb\"\u003eputs\u003c/span\u003e \u003cspan class=\"err\"\u003e㌰太郎\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eto_s\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e# applepen\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"eyes-parseyを読む\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#eyes-parsey%E3%82%92%E8%AA%AD%E3%82%80\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cimg alt=\":eyes:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png\" title=\":eyes:\" width=\"20\"\u003e parse.yを読む\u003c/h2\u003e\n\n\u003cp\u003eRubyのシンタックスはparse.yで定義されています。\u003c/p\u003e\n\n\u003cp\u003eparse.yを読んで以下の表現がわかれば\u003ccode\u003e.{}\u003c/code\u003e演算子を定義できそうです。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eレシーバー\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eメソッド名\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003e{\u003c/code\u003e と \u003ccode\u003e}\u003c/code\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eparse.yはだいたい1万行ちょっとあるうち半分ぐらいまでsyntaxが定義されててその下にトークン切り出す処理があります。\u003cbr\u003e\n色々定義されてるとこにはRipper向けのコードが挟まっているので雑にsyntax足すなら1万行のうちの前半分、それぞれの定義の上の方だけ読めばよさそうです \u003cimg alt=\":ok_hand:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f44c.png\" title=\":ok_hand:\" width=\"20\"\u003e \u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003eなまえ : トークン1 トークン2\n         {\n           /*%%%*/\n             $$ = じっこうされるやつ\n           /*%\n             $$ = Ripperのためのもろもろ\n           %*/\n        }\n    ;\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"メソッド名の表し方\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%90%8D%E3%81%AE%E8%A1%A8%E3%81%97%E6%96%B9\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eメソッド名の表し方\u003c/h3\u003e\n\n\u003cp\u003eとりあえずメソッド名の定義のあたりを探します。メソッド名を定義するときはdefと書くのでdefでgrepします。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e% git grep -n '\"def\"' parse.y\nparse.y:3129:                   token_info_push(\"def\");\nparse.y:11176:    {keyword_def, \"def\"},\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003ekeyword_def\u003c/code\u003eがでてきました。それっぽいのでプロジェクト内で検索すると\u003ccode\u003ek_def\u003c/code\u003eが出てきたので更に\u003ccode\u003ek_def\u003c/code\u003eで検索します。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003ek_def       : keyword_def\n            {\n            token_info_push(\"def\");\n            /*%%%*/\n            $\u0026lt;num\u0026gt;$ = ruby_sourceline;\n            /*%\n            %*/\n            }\n        ;\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003ek_def\u003c/code\u003eの次に来るのは\u003ccode\u003efname\u003c/code\u003eのようです。\u003ccode\u003efname\u003c/code\u003eをしらべれば、メソッド名を表す何かがわかりそうです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003eprimary     : literal\n\n/* 中略 */\n\n        | k_def fname\n            {\n            local_push(0);\n            $\u0026lt;id\u0026gt;$ = current_arg;\n            current_arg = 0;\n            }\n            {\n            $\u0026lt;num\u0026gt;$ = in_def;\n            in_def = 1;\n            }\n          f_arglist\n          bodystmt\n          k_end\n            {\n            /*%%%*/\n            NODE *body = remove_begin($6);\n            reduce_nodes(\u0026amp;body);\n            $$ = NEW_DEFN($2, $5, body, METHOD_VISI_PRIVATE);\n            nd_set_line($$, $\u0026lt;num\u0026gt;1);\n            /*%\n            $$ = dispatch3(def, $2, $5, $6);\n            %*/\n            local_pop();\n            in_def = $\u0026lt;num\u0026gt;4 \u0026amp; 1;\n            current_arg = $\u0026lt;id\u0026gt;3;\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eおっ、\u003ccode\u003efname\u003c/code\u003eがメソッド名を表してるっぽい。Rubyの場合、再定義できる演算子があるのでメソッド名っぽい\u003ccode\u003etIDENTIFIER\u003c/code\u003eの他に\u003ccode\u003eop\u003c/code\u003eや予約語なども引数に取れるようですね。\u003c/p\u003e\n\n\u003cp\u003emethodメソッドでは引数に\u003ccode\u003e:+\u003c/code\u003eなど演算子のメソッド名や大文字のメソッド名\u003ccode\u003e:Integer\u003c/code\u003eも取れるので\u003ccode\u003etIDENTIFIER\u003c/code\u003eや\u003ccode\u003eop\u003c/code\u003eや\u003ccode\u003etCONSTANT\u003c/code\u003eはつかえそうですが予約語の\u003ccode\u003ereswords\u003c/code\u003eは必要なさそうですね。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003efname       : tIDENTIFIER\n        | tCONSTANT\n        | tFID\n        | op\n            {\n            SET_LEX_STATE(EXPR_ENDFN);\n            $$ = $1;\n            }\n        | reswords\n            {\n            SET_LEX_STATE(EXPR_ENDFN);\n            /*%%%*/\n            $$ = $\u0026lt;id\u0026gt;1;\n            /*%\n            $$ = $1;\n            %*/\n            }\n        ;\n\n/* 中略 */\n\nreswords    : keyword__LINE__ | keyword__FILE__ | keyword__ENCODING__\n        | keyword_BEGIN | keyword_END\n        | keyword_alias | keyword_and | keyword_begin\n        | keyword_break | keyword_case | keyword_class | keyword_def\n        | keyword_defined | keyword_do | keyword_else | keyword_elsif\n        | keyword_end | keyword_ensure | keyword_false\n        | keyword_for | keyword_in | keyword_module | keyword_next\n        | keyword_nil | keyword_not | keyword_or | keyword_redo\n        | keyword_rescue | keyword_retry | keyword_return | keyword_self\n        | keyword_super | keyword_then | keyword_true | keyword_undef\n        | keyword_when | keyword_yield | keyword_if | keyword_unless\n        | keyword_while | keyword_until\n        ;\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003etIDENTIFIER\u003c/code\u003eで探すと今回の目的に合ってそうな定義がでてきました。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003eoperation2  : tIDENTIFIER\n        | tCONSTANT\n        | tFID\n        | op\n        ;\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003chr\u003e\n\n\u003cp\u003e捕捉: 書いてる時点では\u003ccode\u003ereswords\u003c/code\u003eいらないと思ってたけどこういうプログラムも書けるからいるっぽい\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"rb\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003enil\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003eputs\u003c/span\u003e \u003cspan class=\"s1\"\u003e'hi'\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\n\u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003esend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"ss\"\u003e:nil\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"メソッドよびだし\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%88%E3%81%B3%E3%81%A0%E3%81%97\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eメソッドよびだし\u003c/h3\u003e\n\n\u003cp\u003eメソッド呼び出し時のレシーバーや\u003ccode\u003e.\u003c/code\u003eやメソッド名の表し方を確認するため定義を探します。メソッド呼び出しは\u003ccode\u003e.\u003c/code\u003eが間にあるので\u003ccode\u003e.\u003c/code\u003eで探してみます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"sh\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"c\"\u003e# git grep -n '\".\"' parse.y`ではうまくgrepできなかった\u003c/span\u003e\n% git \u003cspan class=\"nb\"\u003egrep\u003c/span\u003e \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"'\u003c/span\u003e\u003cspan class=\"se\"\u003e\\.\u003c/span\u003e\u003cspan class=\"s2\"\u003e'\"\u003c/span\u003e parse.y\nparse.y:4976:dot_or_colon       : \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\nparse.y:4988:call_op    : \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\nparse.y:4991:                   \u003cspan class=\"nv\"\u003e$$\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\nparse.y:4993:                   \u003cspan class=\"nv\"\u003e$$\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e ripper_id2sym\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\nparse.y:6064:      \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'$'\u003c/span\u003e: \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'*'\u003c/span\u003e: \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'+'\u003c/span\u003e: \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e:\nparse.y:6275:   BIT\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e';'\u003c/span\u003e, idx\u003cspan class=\"p\"\u003e)\u003c/span\u003e | BIT\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e','\u003c/span\u003e, idx\u003cspan class=\"o\"\u003e)\u003c/span\u003e | BIT\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e, idx\u003cspan class=\"o\"\u003e)\u003c/span\u003e | BIT\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e'='\u003c/span\u003e, idx\u003cspan class=\"o\"\u003e)\u003c/span\u003e | \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\nparse.y:6606:   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003ec \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\nparse.y:7363:   \u003cspan class=\"k\"\u003eelse if\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003ec \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e c \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'e'\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e c \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'E'\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\nparse.y:7381:     \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e:\nparse.y:7395:       tokadd\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\nparse.y:7722:      \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e:            /\u003cspan class=\"k\"\u003e*\u003c/span\u003e \u003cspan class=\"nv\"\u003e$.\u003c/span\u003e: last \u003cspan class=\"nb\"\u003eread \u003c/span\u003eline number \u003cspan class=\"k\"\u003e*\u003c/span\u003e/\nparse.y:8051:         \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e: \u003cspan class=\"o\"\u003e{\u003c/span\u003e\nparse.y:8053:           \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003epeek\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003ec \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'\u0026amp;'\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\nparse.y:8286:   \u003cspan class=\"k\"\u003eelse if\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003ec \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\nparse.y:8386:      \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e:\nparse.y:8388:   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e((\u003c/span\u003ec \u003cspan class=\"o\"\u003e=\u003c/span\u003e nextc\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\nparse.y:8389:       \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e((\u003c/span\u003ec \u003cspan class=\"o\"\u003e=\u003c/span\u003e nextc\u003cspan class=\"o\"\u003e())\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\nparse.y:8400:   \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"s1\"\u003e'.'\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003ecall_op\u003c/code\u003eが怪しいのでそれで検索すると、それっぽいのがでました。レシーバーは\u003ccode\u003eprimary_value\u003c/code\u003eと書き、メソッド呼び出しの\u003ccode\u003e.\u003c/code\u003eは\u003ccode\u003ecall_op\u003c/code\u003eと呼ばれているようです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003emethod_call : fcall paren_args\n\n/* 中略 */\n\n        | primary_value call_op operation2\n            {\n            /*%%%*/\n            $\u0026lt;num\u0026gt;$ = ruby_sourceline;\n            /*% %*/\n            }\n          opt_paren_args\n            {\n            /*%%%*/\n            $$ = NEW_QCALL($2, $1, $3, $5);\n            nd_set_line($$, $\u0026lt;num\u0026gt;4);\n            /*%\n            $$ = dispatch3(call, $1, $2, $3);\n            $$ = method_optarg($$, $5);\n            %*/\n            }\n\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"-と-の表現\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#-%E3%81%A8-%E3%81%AE%E8%A1%A8%E7%8F%BE\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003e{\u003c/code\u003e と \u003ccode\u003e}\u003c/code\u003eの表現\u003c/h3\u003e\n\n\u003cp\u003egrepしたらすぐみつかった。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e% git grep -n \"'{'\" parse.y\nparse.y:1068:             '{' top_compstmt '}'\nparse.y:1168:             '{' top_compstmt '}'\nparse.y:1280:           | keyword_END '{' compstmt '}'\nparse.y:3720:brace_block        : '{'\nparse.y:5771:    if (peek('{')) {  /* handle \\u{...} form */\nparse.y:6144:       if (c2 == '$' || c2 == '@' || c2 == '{') {\nparse.y:6312:      case '{':\nparse.y:7582:   else if (term == '{') term = '}';\nparse.y:8541:      case '{':\nparse.y:8554:       c = '{';          /* block (primary) */\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e普通に\u003ccode\u003e'{'\u003c/code\u003eと\u003ccode\u003e'}'\u003c/code\u003eを書けばよさそうですね!\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003etop_stmt    : stmt\n        | keyword_BEGIN\n            {\n            /*%%%*/\n            /* local_push(0); */\n            /*%\n            %*/\n            }\n          '{' top_compstmt '}'\n            {\n            /*%%%*/\n            ruby_eval_tree_begin = block_append(ruby_eval_tree_begin,\n                                $4);\n            /* NEW_PREEXE($4)); */\n            /* local_pop(); */\n            $$ = NEW_BEGIN(0);\n            /*%\n            $$ = dispatch1(BEGIN, $4);\n            %*/\n            }\n        ;\n\n/* 中略 */\n\nstmt_or_begin   : stmt\n                    {\n            $$ = $1;\n            }\n                | keyword_BEGIN\n            {\n            yyerror(\"BEGIN is permitted only at toplevel\");\n            /*%%%*/\n            /* local_push(0); */\n            /*%\n            %*/\n            }\n          '{' top_compstmt '}'\n            {\n            /*%%%*/\n            ruby_eval_tree_begin = block_append(ruby_eval_tree_begin,\n                                $4);\n            /* NEW_PREEXE($4)); */\n            /* local_pop(); */\n            $$ = NEW_BEGIN(0);\n            /*%\n            $$ = dispatch1(BEGIN, $4);\n            %*/\n            }\n\n/* 中略 */\n\nbrace_block : '{'\n            {\n            /*%%%*/\n            $\u0026lt;num\u0026gt;$ = ruby_sourceline;\n            /*% %*/\n            }\n          brace_body '}'\n            {\n            $$ = $3;\n            /*%%%*/\n            nd_set_line($$, $\u0026lt;num\u0026gt;2);\n            /*% %*/\n            }\n        | keyword_do\n            {\n            /*%%%*/\n            $\u0026lt;num\u0026gt;$ = ruby_sourceline;\n            /*% %*/\n            }\n          do_body keyword_end\n            {\n            $$ = $3;\n            /*%%%*/\n            nd_set_line($$, $\u0026lt;num\u0026gt;2);\n            /*% %*/\n            }\n        ;\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"memo-parseyを書く\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#memo-parsey%E3%82%92%E6%9B%B8%E3%81%8F\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cimg alt=\":pencil:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f4dd.png\" title=\":pencil:\" width=\"20\"\u003e parse.yを書く\u003c/h2\u003e\n\n\u003cp\u003eparse.yをみると\u003ccode\u003eprimary_value\u003c/code\u003eと\u003ccode\u003ecall_op\u003c/code\u003eと\u003ccode\u003e'{'\u003c/code\u003eと\u003ccode\u003eoperation2\u003c/code\u003eと\u003ccode\u003e'}'\u003c/code\u003eを組み合わせればそれっぽいsyntaxが定義できそうなので書いてみましょう。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"書く場所\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E6%9B%B8%E3%81%8F%E5%A0%B4%E6%89%80\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e書く場所\u003c/h3\u003e\n\n\u003cp\u003eどこに書くか悩むんですがメソッド呼び出しやλぽい定義あったんでそのあたりに足します\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003eprimary     : literal\n\n/* 中略 */\n\n        | method_call\n        | method_call brace_block\n            {\n            /*%%%*/\n            block_dup_check($1-\u0026gt;nd_args, $2);\n            $2-\u0026gt;nd_iter = $1;\n            $$ = $2;\n            /*%\n            $$ = method_add_block($1, $2);\n            %*/\n            }\n\n/* このへん? */\n\n        | tLAMBDA lambda\n            {\n            $$ = $2;\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e他の部分の真似をして付け足します。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e        | primary_value call_op '{' operation2 '}'\n            {\n                ここに実装を書く\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"メソッド呼び出しの実装を読む\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%81%AE%E5%AE%9F%E8%A3%85%E3%82%92%E8%AA%AD%E3%82%80\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eメソッド呼び出しの実装を読む\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode\u003eobject.{method}\u003c/code\u003eと書いたとき、Objectに対してmethodメソッドを呼び出したいので参考のためにmethod_callの実装を読みます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003emethod_call : fcall paren_args\n            {\n/* 略 */\n            }\n        | primary_value call_op operation2\n            {\n            /*%%%*/\n            $\u0026lt;num\u0026gt;$ = ruby_sourceline;\n            /*% %*/\n            }\n          opt_paren_args\n            {\n            /*%%%*/\n                        /* \n            $$ = NEW_QCALL($2, $1, $3, $5);\n            nd_set_line($$, $\u0026lt;num\u0026gt;4);\n            /*%\n/* ここからしたはRipper向け定義のよう */\n            $$ = dispatch3(call, $1, $2, $3);\n            $$ = method_optarg($$, $5);\n            %*/\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e定義してる部分の最初のトークンから順番よく\u003ccode\u003e$数字\u003c/code\u003eと入っていくようです。\u003cbr\u003e\nmethod_callの定義の場合は\u003ccode\u003eprimary_value\u003c/code\u003eが\u003ccode\u003e$1\u003c/code\u003eに、\u003ccode\u003ecall_op\u003c/code\u003eが\u003ccode\u003e$2\u003c/code\u003eに、\u003ccode\u003eoperation2\u003c/code\u003eが\u003ccode\u003e$3\u003c/code\u003eに、\u003ccode\u003eruby_source_line\u003c/code\u003eが\u003ccode\u003e$4\u003c/code\u003eに、\u003ccode\u003eopt_paren_args\u003c/code\u003eが\u003ccode\u003e$5\u003c/code\u003eでしょうか。\u003cbr\u003e\n実装部分では\u003ccode\u003eNEW_QCALL(call_op, primary_value, operation2, opt_paren_args)\u003c/code\u003eの結果を\u003ccode\u003e$$\u003c/code\u003eに代入していますね。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNEW_QCALL\u003c/code\u003eの定義を読むと、\u003ccode\u003eNEW_QCALL\u003c/code\u003eではぼっち演算子(\u003ccode\u003e\u0026amp;.\u003c/code\u003e)でメソッドが呼ばれたときに対応するための処理が入り、最終的に\u003ccode\u003eNODE_CALL\u003c/code\u003eが呼ばれているようです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"cp\"\u003e#define CALL_Q_P(q) ((q) == tANDDOT)\n#define NODE_CALL_Q(q) (CALL_Q_P(q) ? NODE_QCALL : NODE_CALL)\n#define NEW_QCALL(q,r,m,a) NEW_NODE(NODE_CALL_Q(q),r,m,a)\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eNODE_CALL\u003c/code\u003eの使い方を調べてみましょう。以下のような関数がありました。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003eNODE\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"nf\"\u003ecall_bin_op_gen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eparser_params\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eparser\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eNODE\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erecv\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eID\u003c/span\u003e \u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eNODE\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003earg1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003evalue_expr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erecv\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003evalue_expr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003earg1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eNEW_CALL\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erecv\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eNEW_LIST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003earg1\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003emethodメソッドを呼ぶ場合、\u003ccode\u003eNODE_CALL\u003c/code\u003eに第一引数にレシーバー、第二引数のidにmethodメソッドのID、第三引数に\u003ccode\u003eNEW_LIST(methodメソッドに渡す引数のNODE)\u003c/code\u003eを渡すとよさそうです。\u003c/p\u003e\n\n\u003cp\u003eそれでは実装してみましょう。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"書く\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E6%9B%B8%E3%81%8F\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e書く\u003c/h3\u003e\n\n\u003cp\u003eまずはNEW_QCALLを呼び出しましょう。第1引数にはcall_opを渡し、第2引数にreceiverを渡します。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e        | primary_value call_op '{' operation2 '}'\n            {\n                $$ = NEW_QCALL($2, $1, methodメソッドのID, NEW_LIST(methodメソッドの引数のNODE);\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003emethodメソッドをのIDを取る方法を調べます。「IDを返す」で検索すると以下の文書が引っかかりました。\u003ccode\u003erb_intern\u003c/code\u003eを使うとよさそうです \u003cimg alt=\":smiley:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f603.png\" title=\":smiley:\" width=\"20\"\u003e \u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"rdoc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003edoc/extension.ja.rdoc\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003eID rb_intern(const char *name) ::\n\n  文字列に対応するIDを返す．\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e        | primary_value call_op '{' operation2 '}'\n            {\n                $$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(methodメソッドの引数のNODE);\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e次はoperation2からmethodメソッドの引数のNODEを作ります。methodメソッドの引数はシンボルなのでシンボルの定義を読むと\u003ccode\u003eNEW_LIT(ID2SYM(〜))\u003c/code\u003eでシンボルが出来るようです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003eliteral     : numeric\n        | symbol\n            {\n            /*%%%*/\n            $$ = NEW_LIT(ID2SYM($1));\n            /*%\n            $$ = dispatch1(symbol_literal, $1);\n            %*/\n            }\n        | dsym\n        ;\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e念のため\u003ccode\u003eNEW_LIT\u003c/code\u003eがNODEを返すか定義を確認\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003enode.h\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"cp\"\u003e#define NEW_LIT(l) NEW_NODE(NODE_LIT,l,0,0)\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eあとは\u003ccode\u003e.{}\u003c/code\u003e演算子の定義のoperation2、\u003ccode\u003e$4\u003c/code\u003eを引数わたしてシンボル化するとよさそうですね!\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e        | primary_value call_op '{' operation2 '}'\n            {\n                $$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(NEW_LIT(ID2SYM($4))));\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eさっそくmakeしてみます。parse.yからparse.cが生成されコンパイルされます。\u003cbr\u003e\nRipperの定義を省いたのでripperのビルドはコケましたが、parse.yはうまくコンパイル出来たようです!\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e% make\n(略)\ngenerating parse.c\ncompiling parse.c\nlinking miniruby\n(略)\ncompiling ripper.c\nripper.y: In function 'ripper_yyparse':\nripper.y:2798:17: warning: assignment makes integer from pointer without a cast [-Wint-conversion]\n     $$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(NEW_LIT(ID2SYM($4))));\n                 ^\nlinking shared-object ripper.bundle\nchecking ../.././parse.y and ../.././ext/ripper/eventids2.c\n*** Following extensions failed to configure:\n../.././ext/openssl/extconf.rb:0: Failed to configure openssl. It will not be installed.\n*** Fix the problems, then remove these directories and try again if you want.\n(略)\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e早速確認用のプログラムを動かしてみましょう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e% cat method_method_syntax.rb\n㌰太郎 = \"\"\nuh = ㌰太郎.{concat}\n\n🍎 = \"apple\"\n✒️ = \"pen\"\n\n[🍎, ✒️].each(\u0026amp;uh)\n\nputs ㌰太郎.to_s\n\n% ./ruby --disable=gems method_method_syntax.rb\nmethod_method_syntax.rb:2: syntax error, unexpected {, expecting '('\nuh = ㌰太郎.{concat}\n                ^\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eあれ、エラーが出ました。\u003ccode\u003eunexpected {\u003c/code\u003eと言われて閉まっています。\u003ccode\u003e{\u003c/code\u003eがうまく認識されてなさそうです。\u003cbr\u003e\n他の\u003ccode\u003e{\u003c/code\u003eを使うsyntaxを確認するとHashの記法の定義では\u003ccode\u003etLBRACE\u003c/code\u003eを使っているようです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e        | tLBRACE assoc_list '}'\n            {\n            /*%%%*/\n            $$ = new_hash($2);\n            /*%\n            $$ = dispatch1(hash, escape_Qundef($2));\n            %*/\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eHashと同じようにtLBRACEで置き換えてみます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"yacc\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eparse.y\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e        | primary_value call_op tLBRACE operation2 '}'\n            {\n                $$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(NEW_LIT(ID2SYM($4))));\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eコンパイルして再実行\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e% make\n% % ./ruby --disable=gems method_method_syntax.rb\napplepen\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e動きました \u003cimg alt=\":green_apple:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f34f.png\" title=\":green_apple:\" width=\"20\"\u003e \u003cimg alt=\":pen_fountain:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f58b.png\" title=\":pen_fountain:\" width=\"20\"\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/hanachin/ruby/tree/method_method_syntax\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\"\u003ehttps://github.com/hanachin/ruby/tree/method_method_syntax\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"sparklesgemsparkles-まとめ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#sparklesgemsparkles-%E3%81%BE%E3%81%A8%E3%82%81\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cimg alt=\":sparkles:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/2728.png\" title=\":sparkles:\" width=\"20\"\u003e\u003cimg alt=\":gem:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f48e.png\" title=\":gem:\" width=\"20\"\u003e\u003cimg alt=\":sparkles:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/2728.png\" title=\":sparkles:\" width=\"20\"\u003e まとめ\u003c/h2\u003e\n\n\u003cp\u003eparse.yを読み書きして\u003ccode\u003e.{}\u003c/code\u003e演算子を追加してみました\u003cimg alt=\":sparkles:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/2728.png\" title=\":sparkles:\" width=\"20\"\u003e\u003cbr\u003e\nparse.yいじると普段変更できないsyntaxを変更出来るので楽しいですね \u003cimg alt=\":leopard:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f406.png\" title=\":leopard:\" width=\"20\"\u003e \u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"hibiscus-okinawarbについて-pig2-\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#hibiscus-okinawarb%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-pig2-\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cimg alt=\":hibiscus:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f33a.png\" title=\":hibiscus:\" width=\"20\"\u003e Okinawa.rbについて \u003cimg alt=\":pig2:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f416.png\" title=\":pig2:\" width=\"20\"\u003e \u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"http://qiita.com/advent-calendar/2016/okinawarb\"\u003eOkinawa.rbのAdvent Calendar 2016\u003c/a\u003e は記事を読む人・書く人を募集しています。\u003c/p\u003e\n\n\u003cp\u003eOkinawa.rbは参加者も募集しています \u003cimg alt=\":airplane:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/2708-fe0f.png\" title=\":airplane:\" width=\"20\"\u003e\u003cimg alt=\":pineapple:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f34d.png\" title=\":pineapple:\" width=\"20\"\u003e \u003cbr\u003e\n開催情報はDoorkeeperに載っています。毎月どこかの週の水曜日の夜に開催しています \u003cimg alt=\":watermelon:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f349.png\" title=\":watermelon:\" width=\"20\"\u003e  \u003cimg alt=\":calendar_spiral:\" class=\"emoji\" height=\"20\" src=\"https://cdn.qiita.com/emoji/twemoji/unicode/1f5d3.png\" title=\":calendar_spiral:\" width=\"20\"\u003e\u003cbr\u003e\n\u003ca href=\"https://okinawarb.doorkeeper.jp\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\"\u003ehttps://okinawarb.doorkeeper.jp\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e流れ的には雑談、初対面の人がいるときは自己紹介、もくもく、解散です。(僕はもくもくとRubyのソースを読んだりしています)\u003c/p\u003e\n\n\u003cp\u003e次回は2016-12-14（水）19:00 - 22:00です。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"参考\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%8F%82%E8%80%83\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e参考\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://amzn.to/2huecOL\" rel=\"nofollow noopener\" target=\"_blank\"\u003eRubyのしくみ　Ruby Under a Microscope\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e- \u003ca href=\"http://i.loveruby.net/ja/rhg/\" rel=\"nofollow noopener\" target=\"_blank\"\u003e『Rubyソースコード完全解説』サポートページ\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://magazine.rubyist.net/?0031-parsey\" rel=\"nofollow noopener\" target=\"_blank\"\u003eRubyist Magazine - parse.y の歩き方 - ワシの Ruby は 4 式まであるぞ -\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","body":":hibiscus: [Okinawa.rbのAdvent Calendar 2016](http://qiita.com/advent-calendar/2016/okinawarb) :pig2: 10日目です。\n\nRubyでMethodオブジェクトを取り出すsyntaxが欲しいときってありますよね。ruby-coreで`o.:method`や`o[.method]`や`o-\u003emethod`などが提案されていますがしっくりこないみたいです。\nhttps://bugs.ruby-lang.org/issues/12125#change-57209\n\n\nRubyのsyntaxをいじる練習に提案されているsyntaxとは別のsyntaxを雑に実装してみようと思います。\n\n:bulb: どういうsyntaxを実装するか\n----\n\nここにオブジェクトがあります。\n\n```rb\no = Object.new\n```\n\nオブジェクトのmethodメソッドの取り出し方を考えます。\n\nとりだすメソッドの名前を指定しないと取り出せないので、とりあえずmethodと書く必要はあるでしょう。\n\n```rb\no /*何かしらのsyntax*/ method\n```\n\nるりまの[Rubyで使われる記号の意味](https://docs.ruby-lang.org/ja/latest/doc/symref.html)や[リテラル](https://docs.ruby-lang.org/ja/latest/doc/spec=2fliteral.html)のページを見ると記号はだいたい使われていそうです。\n\nRubyではProcをつくるときに`-\u003e { }`、ブロックを作るときに`foo { }`のように`{}`を使うことが多いですね。methodメソッドもProcやブロックと同じようにcallできるので同じように`{}`を使って書きたいです。\nなので、今回は`receiver.{method}`でMethodオブジェクトを取り出せるようにしてみましょう。\n\n以降`.{}`演算子と呼びます。\n\n:wrench: 準備\n----\n\n```console\n% git clone git://github.com/ruby/ruby.git\n% cd ruby\n% git fetch --tags\n% git checkout -b method_method_syntax v2_4_0_preview3\n```\n\n今回はsyntax雑に足してみるのが目的なのでビルドは各自READMEを読んでやっていき :muscle:\nhttps://github.com/ruby/ruby#how-to-compile-and-install\n\n:apple::pen_fountain: テスト\n----\n\n雑に足すだけなので以下でapplepenと表示されればいいことにします。\n\n```rb\n㌰太郎 = \"\"\nuh = ㌰太郎.{concat}\n\n🍎 = \"apple\"\n✒️ = \"pen\"\n\n[🍎, ✒️].each(\u0026uh)\n\nputs ㌰太郎.to_s\n# applepen\n```\n\n:eyes: parse.yを読む\n----\n\nRubyのシンタックスはparse.yで定義されています。\n\nparse.yを読んで以下の表現がわかれば`.{}`演算子を定義できそうです。\n\n- レシーバー\n- `.`\n- メソッド名\n- `{` と `}`\n\n\nparse.yはだいたい1万行ちょっとあるうち半分ぐらいまでsyntaxが定義されててその下にトークン切り出す処理があります。\n色々定義されてるとこにはRipper向けのコードが挟まっているので雑にsyntax足すなら1万行のうちの前半分、それぞれの定義の上の方だけ読めばよさそうです :ok_hand: \n\n```parse.y\nなまえ : トークン1 トークン2\n         {\n           /*%%%*/\n             $$ = じっこうされるやつ\n           /*%\n             $$ = Ripperのためのもろもろ\n           %*/\n        }\n    ;\n```\n\n### メソッド名の表し方\n\nとりあえずメソッド名の定義のあたりを探します。メソッド名を定義するときはdefと書くのでdefでgrepします。\n\n```\n% git grep -n '\"def\"' parse.y\nparse.y:3129:                   token_info_push(\"def\");\nparse.y:11176:    {keyword_def, \"def\"},\n```\n\n\n`keyword_def`がでてきました。それっぽいのでプロジェクト内で検索すると`k_def`が出てきたので更に`k_def`で検索します。\n\n```parse.y\nk_def\t\t: keyword_def\n\t\t    {\n\t\t\ttoken_info_push(\"def\");\n\t\t    /*%%%*/\n\t\t\t$\u003cnum\u003e$ = ruby_sourceline;\n\t\t    /*%\n\t\t    %*/\n\t\t    }\n\t\t;\n```\n\n`k_def`の次に来るのは`fname`のようです。`fname`をしらべれば、メソッド名を表す何かがわかりそうです。\n\n```parse.y\nprimary\t\t: literal\n\n/* 中略 */\n\n\t\t| k_def fname\n\t\t    {\n\t\t\tlocal_push(0);\n\t\t\t$\u003cid\u003e$ = current_arg;\n\t\t\tcurrent_arg = 0;\n\t\t    }\n\t\t    {\n\t\t\t$\u003cnum\u003e$ = in_def;\n\t\t\tin_def = 1;\n\t\t    }\n\t\t  f_arglist\n\t\t  bodystmt\n\t\t  k_end\n\t\t    {\n\t\t    /*%%%*/\n\t\t\tNODE *body = remove_begin($6);\n\t\t\treduce_nodes(\u0026body);\n\t\t\t$$ = NEW_DEFN($2, $5, body, METHOD_VISI_PRIVATE);\n\t\t\tnd_set_line($$, $\u003cnum\u003e1);\n\t\t    /*%\n\t\t\t$$ = dispatch3(def, $2, $5, $6);\n\t\t    %*/\n\t\t\tlocal_pop();\n\t\t\tin_def = $\u003cnum\u003e4 \u0026 1;\n\t\t\tcurrent_arg = $\u003cid\u003e3;\n\t\t    }\n```\n\nおっ、`fname`がメソッド名を表してるっぽい。Rubyの場合、再定義できる演算子があるのでメソッド名っぽい`tIDENTIFIER`の他に`op`や予約語なども引数に取れるようですね。\n\nmethodメソッドでは引数に`:+`など演算子のメソッド名や大文字のメソッド名`:Integer`も取れるので`tIDENTIFIER`や`op`や`tCONSTANT`はつかえそうですが予約語の`reswords`は必要なさそうですね。\n\n```parse.y\nfname\t\t: tIDENTIFIER\n\t\t| tCONSTANT\n\t\t| tFID\n\t\t| op\n\t\t    {\n\t\t\tSET_LEX_STATE(EXPR_ENDFN);\n\t\t\t$$ = $1;\n\t\t    }\n\t\t| reswords\n\t\t    {\n\t\t\tSET_LEX_STATE(EXPR_ENDFN);\n\t\t    /*%%%*/\n\t\t\t$$ = $\u003cid\u003e1;\n\t\t    /*%\n\t\t\t$$ = $1;\n\t\t    %*/\n\t\t    }\n\t\t;\n\n/* 中略 */\n\nreswords\t: keyword__LINE__ | keyword__FILE__ | keyword__ENCODING__\n\t\t| keyword_BEGIN | keyword_END\n\t\t| keyword_alias | keyword_and | keyword_begin\n\t\t| keyword_break | keyword_case | keyword_class | keyword_def\n\t\t| keyword_defined | keyword_do | keyword_else | keyword_elsif\n\t\t| keyword_end | keyword_ensure | keyword_false\n\t\t| keyword_for | keyword_in | keyword_module | keyword_next\n\t\t| keyword_nil | keyword_not | keyword_or | keyword_redo\n\t\t| keyword_rescue | keyword_retry | keyword_return | keyword_self\n\t\t| keyword_super | keyword_then | keyword_true | keyword_undef\n\t\t| keyword_when | keyword_yield | keyword_if | keyword_unless\n\t\t| keyword_while | keyword_until\n\t\t;\n```\n\n`tIDENTIFIER`で探すと今回の目的に合ってそうな定義がでてきました。\n\n```parse.y\noperation2\t: tIDENTIFIER\n\t\t| tCONSTANT\n\t\t| tFID\n\t\t| op\n\t\t;\n```\n\n\n----\n\n捕捉: 書いてる時点では`reswords`いらないと思ってたけどこういうプログラムも書けるからいるっぽい\n\n```rb\ndef nil\n  puts 'hi'\nend\n\nself.send(:nil)\n```\n\n### メソッドよびだし\n\nメソッド呼び出し時のレシーバーや`.`やメソッド名の表し方を確認するため定義を探します。メソッド呼び出しは`.`が間にあるので`.`で探してみます。\n\n```sh\n# git grep -n '\".\"' parse.y`ではうまくgrepできなかった\n% git grep -n \"'\\.'\" parse.y\nparse.y:4976:dot_or_colon       : '.'\nparse.y:4988:call_op    : '.'\nparse.y:4991:                   $$ = '.';\nparse.y:4993:                   $$ = ripper_id2sym('.');\nparse.y:6064:      case '$': case '*': case '+': case '.':\nparse.y:6275:   BIT(';', idx) | BIT(',', idx) | BIT('.', idx) | BIT('=', idx) | \\\nparse.y:6606:   if (c == '.') {\nparse.y:7363:   else if (c == '.' || c == 'e' || c == 'E') {\nparse.y:7381:     case '.':\nparse.y:7395:       tokadd('.');\nparse.y:7722:      case '.':            /* $.: last read line number */\nparse.y:8051:         case '.': {\nparse.y:8053:           if (peek('.') == (c == '\u0026')) {\nparse.y:8286:   else if (c == '.') {\nparse.y:8386:      case '.':\nparse.y:8388:   if ((c = nextc()) == '.') {\nparse.y:8389:       if ((c = nextc()) == '.') {\nparse.y:8400:   return '.';\n```\n\n`call_op`が怪しいのでそれで検索すると、それっぽいのがでました。レシーバーは`primary_value`と書き、メソッド呼び出しの`.`は`call_op`と呼ばれているようです。\n\n```parse.y\nmethod_call\t: fcall paren_args\n\n/* 中略 */\n\n\t\t| primary_value call_op operation2\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t$\u003cnum\u003e$ = ruby_sourceline;\n\t\t    /*% %*/\n\t\t    }\n\t\t  opt_paren_args\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t$$ = NEW_QCALL($2, $1, $3, $5);\n\t\t\tnd_set_line($$, $\u003cnum\u003e4);\n\t\t    /*%\n\t\t\t$$ = dispatch3(call, $1, $2, $3);\n\t\t\t$$ = method_optarg($$, $5);\n\t\t    %*/\n\t\t    }\n\n```\n\n\n### `{` と `}`の表現\n\ngrepしたらすぐみつかった。\n\n```\n% git grep -n \"'{'\" parse.y\nparse.y:1068:             '{' top_compstmt '}'\nparse.y:1168:             '{' top_compstmt '}'\nparse.y:1280:           | keyword_END '{' compstmt '}'\nparse.y:3720:brace_block        : '{'\nparse.y:5771:    if (peek('{')) {  /* handle \\u{...} form */\nparse.y:6144:       if (c2 == '$' || c2 == '@' || c2 == '{') {\nparse.y:6312:      case '{':\nparse.y:7582:   else if (term == '{') term = '}';\nparse.y:8541:      case '{':\nparse.y:8554:       c = '{';          /* block (primary) */\n```\n\n普通に`'{'`と`'}'`を書けばよさそうですね!\n\n```parse.y\ntop_stmt\t: stmt\n\t\t| keyword_BEGIN\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t/* local_push(0); */\n\t\t    /*%\n\t\t    %*/\n\t\t    }\n\t\t  '{' top_compstmt '}'\n\t\t    {\n\t\t    /*%%%*/\n\t\t\truby_eval_tree_begin = block_append(ruby_eval_tree_begin,\n\t\t\t\t\t\t\t    $4);\n\t\t\t/* NEW_PREEXE($4)); */\n\t\t\t/* local_pop(); */\n\t\t\t$$ = NEW_BEGIN(0);\n\t\t    /*%\n\t\t\t$$ = dispatch1(BEGIN, $4);\n\t\t    %*/\n\t\t    }\n\t\t;\n\n/* 中略 */\n\nstmt_or_begin\t: stmt\n                    {\n\t\t\t$$ = $1;\n\t\t    }\n                | keyword_BEGIN\n\t\t    {\n\t\t\tyyerror(\"BEGIN is permitted only at toplevel\");\n\t\t    /*%%%*/\n\t\t\t/* local_push(0); */\n\t\t    /*%\n\t\t    %*/\n\t\t    }\n\t\t  '{' top_compstmt '}'\n\t\t    {\n\t\t    /*%%%*/\n\t\t\truby_eval_tree_begin = block_append(ruby_eval_tree_begin,\n\t\t\t\t\t\t\t    $4);\n\t\t\t/* NEW_PREEXE($4)); */\n\t\t\t/* local_pop(); */\n\t\t\t$$ = NEW_BEGIN(0);\n\t\t    /*%\n\t\t\t$$ = dispatch1(BEGIN, $4);\n\t\t    %*/\n\t\t    }\n\n/* 中略 */\n\nbrace_block\t: '{'\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t$\u003cnum\u003e$ = ruby_sourceline;\n\t\t    /*% %*/\n\t\t    }\n\t\t  brace_body '}'\n\t\t    {\n\t\t\t$$ = $3;\n\t\t    /*%%%*/\n\t\t\tnd_set_line($$, $\u003cnum\u003e2);\n\t\t    /*% %*/\n\t\t    }\n\t\t| keyword_do\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t$\u003cnum\u003e$ = ruby_sourceline;\n\t\t    /*% %*/\n\t\t    }\n\t\t  do_body keyword_end\n\t\t    {\n\t\t\t$$ = $3;\n\t\t    /*%%%*/\n\t\t\tnd_set_line($$, $\u003cnum\u003e2);\n\t\t    /*% %*/\n\t\t    }\n\t\t;\n```\n\n:memo: parse.yを書く\n----\n\nparse.yをみると`primary_value`と`call_op`と`'{'`と`operation2`と`'}'`を組み合わせればそれっぽいsyntaxが定義できそうなので書いてみましょう。\n\n\n### 書く場所\nどこに書くか悩むんですがメソッド呼び出しやλぽい定義あったんでそのあたりに足します\n\n```parse.y\nprimary\t\t: literal\n\n/* 中略 */\n\n\t\t| method_call\n\t\t| method_call brace_block\n\t\t    {\n\t\t    /*%%%*/\n\t\t\tblock_dup_check($1-\u003end_args, $2);\n\t\t\t$2-\u003end_iter = $1;\n\t\t\t$$ = $2;\n\t\t    /*%\n\t\t\t$$ = method_add_block($1, $2);\n\t\t    %*/\n\t\t    }\n\n/* このへん? */\n\n\t\t| tLAMBDA lambda\n\t\t    {\n\t\t\t$$ = $2;\n\t\t    }\n```\n\n他の部分の真似をして付け足します。\n\n```parse.y\n\t\t| primary_value call_op '{' operation2 '}'\n\t\t\t{\n\t\t\t\tここに実装を書く\n\t\t\t}\n```\n\n### メソッド呼び出しの実装を読む\n\n`object.{method}`と書いたとき、Objectに対してmethodメソッドを呼び出したいので参考のためにmethod_callの実装を読みます。\n\n```parse.y\nmethod_call\t: fcall paren_args\n\t\t    {\n/* 略 */\n\t\t    }\n\t\t| primary_value call_op operation2\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t$\u003cnum\u003e$ = ruby_sourceline;\n\t\t    /*% %*/\n\t\t    }\n\t\t  opt_paren_args\n\t\t    {\n\t\t    /*%%%*/\n                        /* \n\t\t\t$$ = NEW_QCALL($2, $1, $3, $5);\n\t\t\tnd_set_line($$, $\u003cnum\u003e4);\n\t\t    /*%\n/* ここからしたはRipper向け定義のよう */\n\t\t\t$$ = dispatch3(call, $1, $2, $3);\n\t\t\t$$ = method_optarg($$, $5);\n\t\t    %*/\n\t\t    }\n```\n\n定義してる部分の最初のトークンから順番よく`$数字`と入っていくようです。\nmethod_callの定義の場合は`primary_value`が`$1`に、`call_op`が`$2`に、`operation2`が`$3`に、`ruby_source_line`が`$4`に、`opt_paren_args`が`$5`でしょうか。\n実装部分では`NEW_QCALL(call_op, primary_value, operation2, opt_paren_args)`の結果を`$$`に代入していますね。\n\n`NEW_QCALL`の定義を読むと、`NEW_QCALL`ではぼっち演算子(`\u0026.`)でメソッドが呼ばれたときに対応するための処理が入り、最終的に`NODE_CALL`が呼ばれているようです。\n\n```c:parse.y\n#define CALL_Q_P(q) ((q) == tANDDOT)\n#define NODE_CALL_Q(q) (CALL_Q_P(q) ? NODE_QCALL : NODE_CALL)\n#define NEW_QCALL(q,r,m,a) NEW_NODE(NODE_CALL_Q(q),r,m,a)\n```\n\n`NODE_CALL`の使い方を調べてみましょう。以下のような関数がありました。\n\n```c:parse.y\nstatic NODE *\ncall_bin_op_gen(struct parser_params *parser, NODE *recv, ID id, NODE *arg1)\n{\n    value_expr(recv);\n    value_expr(arg1);\n    return NEW_CALL(recv, id, NEW_LIST(arg1));\n}\n```\n\nmethodメソッドを呼ぶ場合、`NODE_CALL`に第一引数にレシーバー、第二引数のidにmethodメソッドのID、第三引数に`NEW_LIST(methodメソッドに渡す引数のNODE)`を渡すとよさそうです。\n\nそれでは実装してみましょう。\n\n### 書く\n\nまずはNEW_QCALLを呼び出しましょう。第1引数にはcall_opを渡し、第2引数にreceiverを渡します。\n\n```parse.y\n\t\t| primary_value call_op '{' operation2 '}'\n\t\t\t{\n\t\t\t\t$$ = NEW_QCALL($2, $1, methodメソッドのID, NEW_LIST(methodメソッドの引数のNODE);\n\t\t\t}\n```\n\nmethodメソッドをのIDを取る方法を調べます。「IDを返す」で検索すると以下の文書が引っかかりました。`rb_intern`を使うとよさそうです :smiley: \n\n```doc/extension.ja.rdoc\nID rb_intern(const char *name) ::\n\n  文字列に対応するIDを返す．\n```\n\n```parse.y\n\t\t| primary_value call_op '{' operation2 '}'\n\t\t\t{\n\t\t\t\t$$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(methodメソッドの引数のNODE);\n\t\t\t}\n```\n\n次はoperation2からmethodメソッドの引数のNODEを作ります。methodメソッドの引数はシンボルなのでシンボルの定義を読むと`NEW_LIT(ID2SYM(〜))`でシンボルが出来るようです。\n\n```parse.y\nliteral\t\t: numeric\n\t\t| symbol\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t$$ = NEW_LIT(ID2SYM($1));\n\t\t    /*%\n\t\t\t$$ = dispatch1(symbol_literal, $1);\n\t\t    %*/\n\t\t    }\n\t\t| dsym\n\t\t;\n```\n\n念のため`NEW_LIT`がNODEを返すか定義を確認\n\n```c:node.h\n#define NEW_LIT(l) NEW_NODE(NODE_LIT,l,0,0)\n```\n\nあとは`.{}`演算子の定義のoperation2、`$4`を引数わたしてシンボル化するとよさそうですね!\n\n```parse.y\n\t\t| primary_value call_op '{' operation2 '}'\n\t\t\t{\n\t\t\t\t$$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(NEW_LIT(ID2SYM($4))));\n\t\t\t}\n```\n\nさっそくmakeしてみます。parse.yからparse.cが生成されコンパイルされます。\nRipperの定義を省いたのでripperのビルドはコケましたが、parse.yはうまくコンパイル出来たようです!\n\n```\n% make\n(略)\ngenerating parse.c\ncompiling parse.c\nlinking miniruby\n(略)\ncompiling ripper.c\nripper.y: In function 'ripper_yyparse':\nripper.y:2798:17: warning: assignment makes integer from pointer without a cast [-Wint-conversion]\n     $$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(NEW_LIT(ID2SYM($4))));\n                 ^\nlinking shared-object ripper.bundle\nchecking ../.././parse.y and ../.././ext/ripper/eventids2.c\n*** Following extensions failed to configure:\n../.././ext/openssl/extconf.rb:0: Failed to configure openssl. It will not be installed.\n*** Fix the problems, then remove these directories and try again if you want.\n(略)\n```\n\n早速確認用のプログラムを動かしてみましょう。\n\n```\n% cat method_method_syntax.rb\n㌰太郎 = \"\"\nuh = ㌰太郎.{concat}\n\n🍎 = \"apple\"\n✒️ = \"pen\"\n\n[🍎, ✒️].each(\u0026uh)\n\nputs ㌰太郎.to_s\n\n% ./ruby --disable=gems method_method_syntax.rb\nmethod_method_syntax.rb:2: syntax error, unexpected {, expecting '('\nuh = ㌰太郎.{concat}\n                ^\n```\n\nあれ、エラーが出ました。`unexpected {`と言われて閉まっています。`{`がうまく認識されてなさそうです。\n他の`{`を使うsyntaxを確認するとHashの記法の定義では`tLBRACE`を使っているようです。\n\n```parse.y\n\t\t| tLBRACE assoc_list '}'\n\t\t    {\n\t\t    /*%%%*/\n\t\t\t$$ = new_hash($2);\n\t\t    /*%\n\t\t\t$$ = dispatch1(hash, escape_Qundef($2));\n\t\t    %*/\n\t\t    }\n```\n\nHashと同じようにtLBRACEで置き換えてみます。\n\n```parse.y\n\t\t| primary_value call_op tLBRACE operation2 '}'\n\t\t\t{\n\t\t\t\t$$ = NEW_QCALL($2, $1, rb_intern(\"method\"), NEW_LIST(NEW_LIT(ID2SYM($4))));\n\t\t\t}\n```\n\nコンパイルして再実行\n\n```\n% make\n% % ./ruby --disable=gems method_method_syntax.rb\napplepen\n```\n\n動きました :green_apple: :pen_fountain: \n\nhttps://github.com/hanachin/ruby/tree/method_method_syntax\n\n:sparkles::gem::sparkles: まとめ\n----\n\nparse.yを読み書きして`.{}`演算子を追加してみました:sparkles:\nparse.yいじると普段変更できないsyntaxを変更出来るので楽しいですね :leopard: \n\n:hibiscus: Okinawa.rbについて :pig2: \n----\n\n[Okinawa.rbのAdvent Calendar 2016](http://qiita.com/advent-calendar/2016/okinawarb) は記事を読む人・書く人を募集しています。\n\nOkinawa.rbは参加者も募集しています :airplane::pineapple: \n開催情報はDoorkeeperに載っています。毎月どこかの週の水曜日の夜に開催しています :watermelon:  :calendar_spiral:\nhttps://okinawarb.doorkeeper.jp\n\n流れ的には雑談、初対面の人がいるときは自己紹介、もくもく、解散です。(僕はもくもくとRubyのソースを読んだりしています)\n\n次回は2016-12-14（水）19:00 - 22:00です。\n\n参考\n----\n\n- [Rubyのしくみ　Ruby Under a Microscope](http://amzn.to/2huecOL)\n- - [『Rubyソースコード完全解説』サポートページ](http://i.loveruby.net/ja/rhg/)\n- [Rubyist Magazine - parse.y の歩き方 - ワシの Ruby は 4 式まであるぞ -](http://magazine.rubyist.net/?0031-parsey)\n","coediting":false,"comments_count":0,"created_at":"2016-12-10T16:14:32+09:00","group":null,"id":"78c1594362a88269e73d","likes_count":4,"private":false,"reactions_count":0,"tags":[{"name":"Ruby","versions":[]}],"title":"Rubyに雑に演算子を足す","updated_at":"2016-12-10T16:29:04+09:00","url":"https://qiita.com/hanachin_/items/78c1594362a88269e73d","user":{"description":"既婚バイ","facebook_id":"seiei.higa","followees_count":166,"followers_count":120,"github_login_name":"hanachin","id":"hanachin_","items_count":55,"linkedin_id":"","location":"Naha, Okinawa, Japan","name":"Seiei Miyagi","organization":"YassLab","permanent_id":2074,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/2074/profile-images/1511092027","twitter_screen_name":"hanachin_","website_url":""},"page_views_count":null}]